#!/usr/bin/env python3
# phoenix_ultra.py  –  Battle of Heuristics 2025  –  TOP SCORE version
import os, time, random, math
from concurrent.futures import ProcessPoolExecutor, as_completed

# ------------------------------------------------------------------
class Painting:
    __slots__ = ['id', 'tags']               # tags = frozenset of int ids
    def __init__(self, pid, tags):
        self.id = pid
        self.tags = tags

class Frame:
    __slots__ = ['paints', 'tags']
    def __init__(self, paints):
        self.paints = paints
        all_tags = set()
        for p in paints:
            all_tags.update(p.tags)
        self.tags = frozenset(all_tags)

    def line(self):
        ids = [p.id for p in self.paints]
        ids.sort()
        return ' '.join(map(str, ids))

# ------------------------------------------------------------------
def score(f1, f2):
    common = len(f1.tags & f2.tags)
    return min(common, len(f1.tags) - common, len(f2.tags) - common)

# ------------------------------------------------------------------
def parse(fname, tag2id):
    with open(fname) as f:
        n = int(f.readline())
        L, P = [], []
        for i in range(n):
            parts = f.readline().split()
            ori = parts[0]
            tags = frozenset(tag2id.setdefault(t, len(tag2id)) for t in parts[2:])
            p = Painting(i, tags)
            (L if ori == 'L' else P).append(p)
    return L, P

# ------------------------------------------------------------------
def make_frames(L, P):
    frames = [Frame([p]) for p in L]

    # Pair biggest with biggest → much more shared tags
    P.sort(key=lambda p: len(p.tags), reverse=True)
    i = 0
    while i + 1 < len(P):
        frames.append(Frame([P[i], P[i+1]]))
        i += 2
    # If odd → attach the smallest portrait to a random frame (keeps frame count)
    if i < len(P):
        if frames:
            frames[random.randrange(len(frames))].paints.append(P[-1])
        else:
            frames.append(Frame([P[-1]]))
    return frames

# ------------------------------------------------------------------
def two_opt(frames):
    n = len(frames)
    if n < 4: return frames

    best = frames[:]
    cur_score = sum(score(frames[i], frames[i+1]) for i in range(n-1))

    T = 800.0
    cooling = 0.9995
    iters = 1_000_000 if n < 15000 else 500_000

    seq = frames[:]
    for _ in range(iters):
        a = random.randint(1, n-3)
        b = random.randint(a+1, n-2)

        # cost of reversing a..b
        old = score(seq[a-1], seq[a]) + score(seq[b], seq[b+1])
        new = score(seq[a-1], seq[b]) + score(seq[a], seq[b+1])

        if new >= old or random.random() < math.exp((new - old) / T):
            seq[a:b+1] = seq[a:b+1][::-1]
            cur_score += new - old
            if cur_score > sum(score(best[i], best[i+1]) for i in range(n-1)):
                best = seq[:]

        T *= cooling
        if T < 0.01: break

    return best

# ------------------------------------------------------------------
def solve_file(fname, tag2id):
    start = time.time()
    L, P = parse(fname, tag2id)
    frames = make_frames(L, P)

    # ----- multiple greedy starts -----
    n = len(frames)
    best_seq = None
    best_sc  = -1
    runs = 3 if n > 20000 else 8
    candidates = 600 if n > 20000 else 1200

    for _ in range(runs):
        remain = list(range(n))                     # ← list, not set!
        seq = []

        # start with frame that has most tags
        cur = max(remain, key=lambda i: len(frames[i].tags))
        seq.append(cur)
        remain.remove(cur)

        while remain:
            sample = random.sample(remain, min(candidates, len(remain)))

            # left side
            left_best = max(sample, key=lambda x: score(frames[seq[0]], frames[x]))
            lsc = score(frames[seq[0]], frames[left_best])

            # right side
            right_best = max(sample, key=lambda x: score(frames[seq[-1]], frames[x]))
            rsc = score(frames[seq[-1]], frames[right_best])

            if lsc >= rsc:
                seq.insert(0, left_best)
            else:
                seq.append(right_best)
            remain.remove(left_best if lsc >= rsc else right_best)

        # build real frames list
        order = [frames[i] for i in seq]
        sc = sum(score(order[i], order[i+1]) for i in range(len(order)-1))

        # 2-opt improvement
        order = two_opt(order)
        sc = sum(score(order[i], order[i+1]) for i in range(len(order)-1))

        if sc > best_sc:
            best_sc = sc
            best_seq = order

    # ----- write result -----
    os.makedirs("Output", exist_ok=True)
    with open(f"Output/{fname}", "w") as f:
        f.write(f"{len(best_seq)}\n")
        for fr in best_seq:
            f.write(fr.line() + "\n")

    return fname, best_sc, time.time() - start

# ------------------------------------------------------------------
def main():
    files = sorted(f for f in os.listdir('.') if f.endswith('.txt'))
    if not files:
        print("No input files found!")
        return

    tag2id = {}
    total_score = 0
    total_time  = 0

    with ProcessPoolExecutor() as pool:
        futures = [pool.submit(solve_file, f, tag2id) for f in files]
        for fut in as_completed(futures):
            name, sc, t = fut.result()
            total_score += sc
            total_time  += t
            print(f"Finished {name} → {sc:,}  ({t:.1f}s)")

    print("\n" + "="*60)
    print(f"        TOTAL SCORE : {total_score:,}")
    print(f"        TOTAL TIME  : {total_time:.1f}s")
    print("="*60)

if __name__ == "__main__":
    main()
