#!/usr/bin/env python3
"""
ADAPTIVE OPTIMIZER - Random Order Only
Battle of Heuristics Challenge Week - Exhibition Opening Optimizer
"""

import sys
import time
import random
import os
from typing import List, Tuple, Set
from collections import defaultdict


class Painting:
    __slots__ = ('id', 'orientation', 'tags', 'tag_count')
    
    def __init__(self, painting_id: int, orientation: str, tags: Set[str]):
        self.id = painting_id
        self.orientation = orientation
        self.tags = tags
        self.tag_count = len(tags)


class Frameglass:
    __slots__ = ('paintings', 'tags', 'tag_count', 'tag_list')
    
    def __init__(self, paintings: List[Painting]):
        self.paintings = paintings
        if len(paintings) == 1:
            self.tags = paintings[0].tags
        else:
            self.tags = paintings[0].tags | paintings[1].tags
        self.tag_count = len(self.tags)
        # Cache as list for faster operations
        self.tag_list = list(self.tags)
    
    def get_output_line(self) -> str:
        return " ".join(str(p.id) for p in self.paintings)


def parse_input(filename: str) -> Tuple[List[Painting], List[Painting]]:
    """Memory-efficient parsing."""
    landscapes = []
    portraits = []
    
    with open(filename, 'r', encoding='utf-8') as f:
        n = int(f.readline().strip())
        
        for i in range(n):
            line = f.readline().strip().split()
            orientation = line[0]
            tags = set(line[2:])
            
            painting = Painting(i, orientation, tags)
            
            if orientation == 'L':
                landscapes.append(painting)
            else:
                portraits.append(painting)
    
    return landscapes, portraits


def create_frameglasses_simple(landscapes: List[Painting], portraits: List[Painting]) -> List[Frameglass]:
    """Simple portrait pairing - use random order."""
    frameglasses = []
    
    # Landscapes are always straightforward
    for painting in landscapes:
        frameglasses.append(Frameglass([painting]))
    
    if not portraits:
        return frameglasses
    
    # Shuffle portraits for random pairing
    random.shuffle(portraits)
    used = [False] * len(portraits)
    
    # Simple pairing in random order
    for i in range(len(portraits)):
        if used[i]:
            continue
            
        p1 = portraits[i]
        best_j = -1
        best_score = -1
        
        # Look for any available pair
        for j in range(i + 1, len(portraits)):
            if used[j]:
                continue
                
            p2 = portraits[j]
            union_size = len(p1.tags | p2.tags)
            score = union_size
            
            if score > best_score:
                best_score = score
                best_j = j
        
        if best_j != -1:
            frameglasses.append(Frameglass([p1, portraits[best_j]]))
            used[i] = True
            used[best_j] = True
        else:
            # Single portrait if no pair found
            frameglasses.append(Frameglass([p1]))
            used[i] = True
    
    return frameglasses


def calculate_local_score_fast(fg1: Frameglass, fg2: Frameglass) -> int:
    """Optimized score calculation using cached tag lists."""
    if fg1.tag_count == 0 or fg2.tag_count == 0:
        return 0
    
    # For small sets, use intersection
    if fg1.tag_count <= fg2.tag_count:
        common = len(fg1.tags & fg2.tags)
    else:
        common = len(fg2.tags & fg1.tags)
    
    only_first = fg1.tag_count - common
    only_second = fg2.tag_count - common
    return min(common, only_first, only_second)


def calculate_total_score_fast(frameglasses: List[Frameglass]) -> int:
    """Calculate total score efficiently."""
    total = 0
    for i in range(len(frameglasses) - 1):
        total += calculate_local_score_fast(frameglasses[i], frameglasses[i+1])
    return total


def order_random_only(frameglasses: List[Frameglass]) -> List[Frameglass]:
    """Use only random order for frameglasses."""
    random.shuffle(frameglasses)
    return frameglasses


def ensure_output_directory():
    """Create output directory if it doesn't exist."""
    output_dir = "output"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f"üìÅ Created output directory: {output_dir}")
    return output_dir


def get_output_path(input_file: str, output_dir: str) -> str:
    """Generate output path with same filename as input in output directory."""
    # Get just the filename without path
    filename = os.path.basename(input_file)
    # Return path in output directory with same filename
    return os.path.join(output_dir, filename)


def solve_with_random_order(input_file: str, output_file: str, verbose: bool = True):
    """Main solver using only random order."""
    if verbose:
        print(f"Processing: {input_file}")
        print("Using RANDOM ORDER only for frameglasses")
        print("Phase 1: Parsing and frameglass creation...")
    
    overall_start = time.time()
    
    # Phase 1: Parse and create frameglasses
    parse_start = time.time()
    landscapes, portraits = parse_input(input_file)
    parse_time = time.time() - parse_start
    
    frame_start = time.time()
    frameglasses = create_frameglasses_simple(landscapes, portraits)
    frame_time = time.time() - frame_start
    
    if verbose:
        print(f"‚úì Phase 1: {parse_time + frame_time:.1f}s ({len(frameglasses)} frameglasses)")
        print("Phase 2: Random ordering...")
    
    # Phase 2: Use only random ordering
    order_start = time.time()
    ordered_frameglasses = order_random_only(frameglasses)
    order_time = time.time() - order_start
    
    # Write output
    write_output(output_file, ordered_frameglasses)
    
    total_time = time.time() - overall_start
    final_score = calculate_total_score_fast(ordered_frameglasses)
    
    if verbose:
        print(f"‚úì Phase 2: {order_time:.1f}s")
        print(f"\nüèÜ Final Score: {final_score:,}")
        print(f"‚è±Ô∏è  Total Time: {total_time:.1f}s")
        print(f"‚úì Output: {output_file}")
    
    return final_score, total_time


def write_output(filename: str, frameglasses: List[Frameglass]):
    """Write output file."""
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"{len(frameglasses)}\n")
        for fg in frameglasses:
            f.write(f"{fg.get_output_line()}\n")


def solve_all_files_random():
    """Process all files using only random order."""
    # Ensure output directory exists
    output_dir = ensure_output_directory()
    
    files = [
        "0_example.txt",
        "1_binary_landscapes.txt", 
        "10_computable_moments.txt",
        "11_randomizing_paintings.txt",
        "110_oily_portraits.txt"
    ]
    
    print("=" * 60)
    print("RANDOM ORDER EXHIBITION OPTIMIZER")
    print("=" * 60)
    print(f"üìÅ Output directory: {output_dir}/")
    print("=" * 60)
    
    total_score = 0
    total_time = 0
    results = []
    
    for input_file in files:
        if not os.path.exists(input_file):
            print(f"‚ö†Ô∏è  Skipping {input_file} (not found)")
            continue
        
        try:
            # Generate output path with same filename in output directory
            output_file = get_output_path(input_file, output_dir)
            file_size_mb = os.path.getsize(input_file) / (1024 * 1024)
            print(f"\nüìÅ Input: {input_file} ({file_size_mb:.1f} MB)")
            print(f"üìÅ Output: {output_file}")
            
            score, elapsed = solve_with_random_order(input_file, output_file, verbose=True)
            total_score += score
            total_time += elapsed
            results.append((input_file, output_file, score, elapsed, file_size_mb))
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            continue
    
    # Summary
    print("\n" + "=" * 60)
    print("FINAL SUMMARY - RANDOM ORDER ONLY")
    print("=" * 60)
    print(f"{'Input File':<25} {'Size':>6} {'Score':>12} {'Time':>8} {'Output File'}")
    print("-" * 60)
    
    for input_file, output_file, score, elapsed, size in results:
        output_filename = os.path.basename(output_file)
        print(f"{input_file:<25} {size:>5.1f}M {score:>12,} {elapsed:>7.1f}s {output_filename}")
    
    print("-" * 60)
    print(f"{'TOTAL':<25} {'':>6} {total_score:>12,} {total_time:>7.1f}s")
    
    return total_score, total_time


if __name__ == "__main__":
    if len(sys.argv) == 1:
        # Batch mode - process all files
        solve_all_files_random()
    else:
        # Single file mode
        input_file = sys.argv[1]
        
        if not os.path.exists(input_file):
            print(f"‚ùå File not found: {input_file}")
            sys.exit(1)
        
        # Ensure output directory exists
        output_dir = ensure_output_directory()
        # Generate output path with same filename in output directory
        output_file = get_output_path(input_file, output_dir)
            
        try:
            print(f"üìÅ Input: {input_file}")
            print(f"üìÅ Output: {output_file}")
            score, elapsed = solve_with_random_order(input_file, output_file)
            print(f"\n‚úÖ SUCCESS! Score: {score:,} | Time: {elapsed:.1f}s")
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
            sys.exit(1)
